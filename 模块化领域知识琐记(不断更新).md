#Feature:
- An autonomous unit of deployment (loose coupling)
- A consistent and unique identity (module ID and version)
- Easily identified and discovered requirements and dependencies (standard compile-time and deployment facilities and meta-information)
- An open and understandable interface (communication contract)
- Hidden implementation details (encapsulation)

#Jigsaw
####Module
- Module declared in module-info.java (module-info.class)
- All new keywords are “scoped”
<pre><code>
module B @ 1.0 {
       ...
}
</code></pre>

####Requires
- Modules require other modules by name (and optionally, version)
<pre><code>
module B @ 1.0 {
       require A @ [2.0,3.0);
}
</code></pre>

####Local
- Requirements can be marked “local”
- Target module is loaded in same classloader
<pre><code>
module B @ 1.0 {
       require local A @ [2.0,3.0);
}
</code></pre>

####Exports
- Modules list their exports, at package and type level
- May include re-exported contents of required modules
<pre><code>
module B @ 1.0 {
       require A @ [2.0,3.0);
       export org.foo.ClassFoo;
       export org.bar.*;
}
</pre></code>

####Friends
- Modules can control which other modules require them
- Compare with “friend” classes in C++
- N.B. permit clause is not versioned.
<pre><code>
module A @ 2.0 {
       permit B;
}
</pre></code>

####Provides
- Modules can logically “provide” other modules names
- Compare with “vir tual packages” in Debian
- Supports substitution, but not refactoring (splits or joins)
<pre><code>
module com.ibm.stax @ 1.0 {
       provide jdk.stax @ 2.0;
}
</pre></code>

####Entry Point
- Modules can have a single entry-point class
- Compare with Main-Class header in Jar manifests.
<pre><code>
module A @ 2.0 {
       permit B;
       class org.foo.Main;
}
</pre><code>

####Versions
- Modules will be versioned
- Requirements use exact version or a range
- No version semantics beyond ordering
