#Feature:
- An autonomous unit of deployment (loose coupling)
- A consistent and unique identity (module ID and version)
- Easily identified and discovered requirements and dependencies (standard compile-time and deployment facilities and meta-information)
- An open and understandable interface (communication contract)
- Hidden implementation details (encapsulation)

#Jigsaw
####Module
- Module declared in module-info.java (module-info.class)
- All new keywords are “scoped”
<pre><code>
module B @ 1.0 {
       ...
}
</code></pre>

####Requires
- Modules require other modules by name (and optionally, version)
<pre><code>
module B @ 1.0 {
       require A @ [2.0,3.0);
}
</code></pre>

####Local
- Requirements can be marked “local”
- Target module is loaded in same classloader
<pre><code>
module B @ 1.0 {
       require local A @ [2.0,3.0);
}
</code></pre>

####Exports
- Modules list their exports, at package and type level
- May include re-exported contents of required modules
<pre><code>
module B @ 1.0 {
       require A @ [2.0,3.0);
       export org.foo.ClassFoo;
       export org.bar.*;
}
</pre></code>

####Friends
- Modules can control which other modules require them
- Compare with “friend” classes in C++
- N.B. permit clause is not versioned.
<pre><code>
module A @ 2.0 {
       permit B;
}
</pre></code>

####Provides
- Modules can logically “provide” other modules names
- Compare with “vir tual packages” in Debian
- Supports substitution, but not refactoring (splits or joins)
<pre><code>
module com.ibm.stax @ 1.0 {
       provide jdk.stax @ 2.0;
}
</pre></code>

####Entry Point
- Modules can have a single entry-point class
- Compare with Main-Class header in Jar manifests.
<pre><code>
module A @ 2.0 {
       permit B;
       class org.foo.Main;
}
</pre></code>

####Versions
- Modules will be versioned
- Requirements use exact version or a range
- No version semantics beyond ordering

#OSGi
####Areas
- Core: the OSGi Framework  
  Modularity  
  Services  
  Lifecycle and Dynamicity  
  Security  

- Enterprise: services & component on top of Core Framework  
  Addressing Enterprise use-cases, such as:  
    Service Distribution  
    Component models and IoC  
    Configuration and Management  
    JavaEE integration  
    Cloud Computing  

- Residential and embedded services/components  

####Modularity
- In OSGi Modules are called Bundles  
- With OSGi Modularity you must declare what a module provides and what it needs.  
  Typically Java packages  
  Can be other capabilities  
- Everything not explicitly declared as provided is internal -> not accessible to other modules  
- Improves maintainability  
  as module boundaries and function must be made clear  
  ￼tends to improve cohesion  
    and reduce coupling  
- Non-monolithic  
  allow for fine-grained updates of the system  
- Concurrent versions  
  multiple versions of the same module can co-exist  
  allows for gradual upgrades  

####OSGi Modularity in Practice
- From a Java point of view. Just use classes as normal:  
<pre><code>
package org.acme.package1;
import org.acme.package2.MyClass;
JavaOne Slide Template Title
...
MyClass ax = new MyClass();
ax.foo()
</pre></code>
- OSGi Module Metadata in MANIFEST.MF  
<pre><code>
Export-Package: org.acme.package1; version=1.2
Import-Package: org.acme.package2; version=[1.1, 2)
</pre></code>
- Compiler support by some, e.g Eclipse javac  
- Runtime enforcement by OSGi Framework  

####Services
- Services are Java Objects (POJOs)  
  registered by Bundles  
  consumed by Bundles  
- “SOA inside the JVM”  
- Services looked up by type and/or custom filter  
  “I want a service that implements org.acme.Payment where location=US”  
  One or many  
- Dynamic! Services can be updated without taking down the consumers  
  OSGi Service Consumers react to dynamism  
How can we increase software reuse?  
- With OSGi Services there is no direct link between the service consumer and provider  
  not even a text or XML file somewhere  
  they communicate through a predefined API  
  improves re-usability  
- In OSGi software reuse is visibly much higher than elsewhere  
- Given clear APIs implementations can be swapped  
  even at runtime  
- OSGi standardizes some Service APIs  
  organizations sometimes do the same  
How can I tailor my services more effectively?  
- Customizations are needed for  
  Premium customers vs community users  
  Customers who bought specific functionality  
  Government vs commercial customers  
  Services can be used to swap in/out customizatios  
- To tailor a service, just provide an alternative for a given API  
- Services can be selected based on API and Properties  
- Properties can be used to find the right set of services for a given customer  
